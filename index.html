<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DFS / Prim / Kruskal / Wilson</title>
  <style>
    body { font-size: 1.1rem; }
    .row { display: flex; gap: 1%; flex-wrap: wrap; align-items: center; margin-bottom: 12px; max-width: 92vmin; }
    button { padding: 0.1em; }
    #grid { display: grid; background: #999; width: 90vmin; margin: 1%; max-width: 90vmin; max-height: 90vmin; height: 90vmin }
    .cell { width: 100%; height: 100%; background: #111; }
    .path { background: #f5f5f5; }
    .current { outline: 2px solid #00c8ff; outline-offset: -2px; }
    .between { background: #b700bf; }
    .room { background: #e9e9e9; }  
    code { background: #f2f200; padding: 1%; }
    select, input { font-size: 1rem; }
    input[type=number] {min-width: 3rem; max-width: 4rem;}
  </style>
</head>
<body>
  <div class="row">   
    <label>Size:
      <input id="size" type="number" min="5" step="2" value="21">
    </label>
    <button id="reset">Reset</button>
    <button id="step">Step</button>
    <button id="auto">Auto: Off</button>
    <label>Algorithm:
      <select id="algo">
        <option value="dfs">DFS Backtracker (±2 carve)</option>
        <option value="prim">Randomized Prim (frontier edges)</option>
        <option value="kruskal">Kruskal (Union-Find walls)</option>
        <option value="wilson">Wilson (loop-erased random walk)</option>
      </select>
    </label>
  </div>

  <div id="grid"></div>
  <span id="status"></span>
  <p>
    Watch what happens on each step:
    <br />
    <small id="deets"></small>
  </p>

  <script>
    const gridEl = document.getElementById('grid');
    const statusEl = document.getElementById('status');
    const sizeEl = document.getElementById('size');
    const algoEl = document.getElementById('algo');
    const btnReset = document.getElementById('reset');
    const btnStep = document.getElementById('step');
    const btnAuto = document.getElementById('auto');
    const deets = document.getElementById('deets');

    let N = 33;
    let maze = [];       // false = wall, true = path
    let cells = [];      // DOM refs
    let autoTimer = null;

    const dirs = [
      [-2, 0], [2, 0], [0, -2], [0, 2],
    ];

    const START = [1, 1];

    const givedeets = (text) => { deets.textContent = text; };

    function isValid(x, y) {
      return x >= 0 && x < N && y >= 0 && y < N;
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function setCell(x, y, isPath) {
      maze[x][y] = isPath;
      const el = cells[x][y];
      el.classList.toggle('path', isPath);
      el.classList.toggle('room', isPath && x % 2 === 1 && y % 2 === 1);
    }

    function clearHighlights() {
      for (let x = 0; x < N; x++) for (let y = 0; y < N; y++) {
        cells[x][y].classList.remove('current');
        cells[x][y].classList.remove('between');
      }
    }

    function buildGrid() {
      gridEl.innerHTML = '';
      gridEl.style.gridTemplateColumns = `repeat(${N}, auto)`;

      cells = Array.from({ length: N }, () => Array(N));
      for (let x = 0; x < N; x++) {
        for (let y = 0; y < N; y++) {
          const el = document.createElement('div');
          el.className = 'cell';
          gridEl.appendChild(el);
          cells[x][y] = el;
        }
      }
    }

    // DFS Backtracker
    const dfsState = {
      stack: [],
      init() {
        this.stack = [];
        const [sx, sy] = START;

        setCell(sx, sy, true);
        this.stack.push([sx, sy]);

        clearHighlights();
        cells[sx][sy].classList.add('current');

        statusEl.textContent = `Algorithm: DFS | Stack: ${this.stack.length} | Carving…`;
        givedeets(`DFS: pick an unvisited neighbor by ±2 and carve the “between” cell at dx/2, dy/2.`);
      },
      step() {
        if (this.stack.length === 0) {
          statusEl.textContent = 'Done. (DFS stack empty)';
          return false;
        }

        clearHighlights();

        const [x, y] = this.stack[this.stack.length - 1];
        cells[x][y].classList.add('current');

        const options = shuffle(dirs.slice());
        for (const [dx, dy] of options) {
          const nx = x + dx;
          const ny = y + dy;

          if (!isValid(nx, ny)) continue;
          if (maze[nx][ny]) continue;

          const bx = x + dx / 2;
          const by = y + dy / 2;

          setCell(bx, by, true);
          setCell(nx, ny, true);

          cells[bx][by].classList.add('between');

          this.stack.push([nx, ny]);
          statusEl.textContent = `Algorithm: DFS | Move: (${x},${y}) -> (${nx},${ny}) | Between: (${bx},${by}) | Stack: ${this.stack.length}`;
          return true;
        }

        this.stack.pop();
        statusEl.textContent = `Algorithm: DFS | Backtrack from (${x},${y}) | Stack: ${this.stack.length}`;
        return true;
      }
    };

    // Randomized Prim
    const primState = {
      frontier: [], // edges: {x,y,nx,ny,bx,by}
      init() {
        this.frontier = [];
        const [sx, sy] = START;

        setCell(sx, sy, true);
        this._addFrontierFrom(sx, sy);

        clearHighlights();
        cells[sx][sy].classList.add('current');

        statusEl.textContent = `Algorithm: Prim | Frontier: ${this.frontier.length} | Growing…`;
        givedeets(`Prim: keep a frontier of edges from carved to uncarved rooms; pick one randomly, carve between + target room.`);
      },
      _addFrontierFrom(x, y) {
        for (const [dx, dy] of dirs) {
          const nx = x + dx;
          const ny = y + dy;
          if (!isValid(nx, ny)) continue;
          if (maze[nx][ny]) continue;

          const bx = x + dx / 2;
          const by = y + dy / 2;
          this.frontier.push({ x, y, nx, ny, bx, by });
        }
      },
      step() {
        while (this.frontier.length > 0) {
          const idx = (Math.random() * this.frontier.length) | 0;
          const edge = this.frontier.splice(idx, 1)[0];

          const { x, y, nx, ny, bx, by } = edge;

          if (!isValid(nx, ny) || maze[nx][ny]) continue;

          clearHighlights();
          cells[x][y].classList.add('current');

          setCell(bx, by, true);
          setCell(nx, ny, true);

          cells[bx][by].classList.add('between');
          cells[nx][ny].classList.add('current');

          this._addFrontierFrom(nx, ny);

          statusEl.textContent =
            `Algorithm: Prim | Add: (${nx},${ny}) via (${x},${y}) | Between: (${bx},${by}) | Frontier: ${this.frontier.length}`;
          return true;
        }

        statusEl.textContent = 'Done. (Prim frontier empty)';
        return false;
      }
    };

    // Kruskal (Union-Find)
    const kruskalState = {
      parent: [],
      rank: [],
      edges: [],
      roomsPerSide: 0,

      _roomId(x, y) {
        const rx = (x - 1) / 2;
        const ry = (y - 1) / 2;
        return rx * this.roomsPerSide + ry;
      },

      _find(a) {
        let p = this.parent[a];
        if (p !== a) this.parent[a] = this._find(p);
        return this.parent[a];
      },

      _union(a, b) {
        a = this._find(a);
        b = this._find(b);
        if (a === b) return false;

        if (this.rank[a] < this.rank[b]) [a, b] = [b, a];
        this.parent[b] = a;
        if (this.rank[a] === this.rank[b]) this.rank[a]++;
        return true;
      },

      init() {
        this.roomsPerSide = (N - 1) / 2;
        const roomCount = this.roomsPerSide * this.roomsPerSide;

        this.parent = Array.from({ length: roomCount }, (_, i) => i);
        this.rank = Array(roomCount).fill(0);
        this.edges = [];

        // carve all rooms open; keep between-cells closed initially
        for (let x = 1; x < N; x += 2) for (let y = 1; y < N; y += 2) setCell(x, y, true);

        // build edges (right + down)
        for (let x = 1; x < N; x += 2) {
          for (let y = 1; y < N; y += 2) {
            const aId = this._roomId(x, y);

            if (x + 2 < N) {
              const nx = x + 2, ny = y;
              const bId = this._roomId(nx, ny);
              this.edges.push({ ax: x, ay: y, bx: nx, by: ny, wx: x + 1, wy: y, aId, bId });
            }
            if (y + 2 < N) {
              const nx = x, ny = y + 2;
              const bId = this._roomId(nx, ny);
              this.edges.push({ ax: x, ay: y, bx: nx, by: ny, wx: x, wy: y + 1, aId, bId });
            }
          }
        }

        shuffle(this.edges);

        clearHighlights();
        const [sx, sy] = START;
        cells[sx][sy].classList.add('current');

        statusEl.textContent = `Algorithm: Kruskal | Walls: ${this.edges.length} | Union-Find ready…`;
        givedeets(`Kruskal: shuffle walls between rooms. If a wall connects different sets, carve it; otherwise skip (cycle).`);
      },

      step() {
        if (this.edges.length === 0) {
          statusEl.textContent = 'Done. (Kruskal walls exhausted)';
          return false;
        }

        const e = this.edges.pop();

        clearHighlights();
        cells[e.ax][e.ay].classList.add('current');
        cells[e.bx][e.by].classList.add('current');
        cells[e.wx][e.wy].classList.add('between');

        const connected = this._union(e.aId, e.bId);
        if (connected) {
          setCell(e.wx, e.wy, true);
          statusEl.textContent =
            `Algorithm: Kruskal | CONNECT sets | Carve wall (${e.wx},${e.wy}) | Walls left: ${this.edges.length}`;
        } else {
          statusEl.textContent =
            `Algorithm: Kruskal | SKIP cycle | Keep wall (${e.wx},${e.wy}) | Walls left: ${this.edges.length}`;
        }
        return true;
      }
    };

    // Wilson (Loop-Erased Random Walk, step-by-step state machine)
    const wilsonState = {
      roomsPerSide: 0,
      roomCount: 0,
      inTree: [],
      remaining: 0,

      // current walk (loop-erased)
      phase: "pick",            // "pick" | "walk" | "carve"
      walkPath: [],             // roomIds (does NOT include the tree-hit target)
      walkIndex: [],            // roomId -> index in walkPath, or -1
      carvePath: null,          // roomIds INCLUDING target (walkPath + [target])
      carveI: 0,

      _coordToId(x, y) {
        const rx = (x - 1) / 2;
        const ry = (y - 1) / 2;
        return rx * this.roomsPerSide + ry;
      },
      _idToCoord(id) {
        const rx = Math.floor(id / this.roomsPerSide);
        const ry = id % this.roomsPerSide;
        return [rx * 2 + 1, ry * 2 + 1];
      },

      _pickNonTreeId() {
        if (this.remaining <= 0) return -1;

        // Near the end, random-try can get unlucky; fall back to scanning.
        if (this.remaining < Math.max(8, this.roomCount / 8)) {
          for (let i = 0; i < this.roomCount; i++) if (!this.inTree[i]) return i;
          return -1;
        }

        // Fast average-case:
        for (let tries = 0; tries < 10000; tries++) {
          const id = (Math.random() * this.roomCount) | 0;
          if (!this.inTree[id]) return id;
        }

        // Fallback scan if the universe hates us today
        for (let i = 0; i < this.roomCount; i++) if (!this.inTree[i]) return i;
        return -1;
      },

      _neighborsOfRoomId(id) {
        const [x, y] = this._idToCoord(id);
        const nbrs = [];
        for (const [dx, dy] of dirs) {
          const nx = x + dx, ny = y + dy;
          if (!isValid(nx, ny)) continue;
          // nx,ny will stay odd if x,y are odd and dx,dy are even (±2)
          nbrs.push({ id: this._coordToId(nx, ny), x: nx, y: ny, bx: (x + nx) / 2, by: (y + ny) / 2, fromX: x, fromY: y });
        }
        return nbrs;
      },

      _markRoomInTree(id) {
        if (this.inTree[id]) return;
        this.inTree[id] = true;
        this.remaining--;
        const [x, y] = this._idToCoord(id);
        setCell(x, y, true);
      },

      _clearWalkIndex() {
        // only clear for rooms that were in the current walkPath
        for (const id of this.walkPath) this.walkIndex[id] = -1;
        this.walkPath.length = 0;
      },

      init() {
        this.roomsPerSide = (N - 1) / 2;
        this.roomCount = this.roomsPerSide * this.roomsPerSide;

        this.inTree = Array(this.roomCount).fill(false);
        this.walkIndex = Array(this.roomCount).fill(-1);

        this.remaining = this.roomCount;
        this.phase = "pick";
        this.walkPath = [];
        this.carvePath = null;
        this.carveI = 0;

        // Start tree with START room (or you can randomize this if you want)
        const [sx, sy] = START;
        const rootId = this._coordToId(sx, sy);
        this._markRoomInTree(rootId);

        clearHighlights();
        cells[sx][sy].classList.add('current');

        statusEl.textContent = `Algorithm: Wilson | In-tree: 1/${this.roomCount} | Starting…`;
        givedeets(`Wilson: pick a random room not in the tree, random-walk until you hit the tree, erase loops as they form, then carve the resulting path into the tree.`);
      },

      step() {
        if (this.remaining <= 0 && this.phase !== "carve" && this.phase !== "walk") {
          statusEl.textContent = 'Done. (Wilson complete)';
          return false;
        }

        if (this.phase === "pick") {
          const startId = this._pickNonTreeId();
          if (startId < 0) {
            statusEl.textContent = 'Done. (Wilson complete)';
            return false;
          }

          // start new loop-erased walk
          this.walkPath = [startId];
          this.walkIndex[startId] = 0;
          this.carvePath = null;
          this.carveI = 0;
          this.phase = "walk";

          clearHighlights();
          const [x, y] = this._idToCoord(startId);
          cells[x][y].classList.add('current');

          statusEl.textContent = `Algorithm: Wilson | Walk start at roomId=${startId} | Remaining rooms: ${this.remaining}`;
          return true;
        }

        if (this.phase === "walk") {
          const headId = this.walkPath[this.walkPath.length - 1];
          const nbrs = this._neighborsOfRoomId(headId);
          const choice = nbrs[(Math.random() * nbrs.length) | 0];

          clearHighlights();
          const [hx, hy] = this._idToCoord(headId);
          cells[hx][hy].classList.add('current');
          cells[choice.bx][choice.by].classList.add('between');

          // Hit the tree: switch to carve
          if (this.inTree[choice.id]) {
            this.carvePath = this.walkPath.concat([choice.id]);
            this.carveI = 0;
            this.phase = "carve";

            const [tx, ty] = this._idToCoord(choice.id);
            cells[tx][ty].classList.add('current');

            statusEl.textContent =
              `Algorithm: Wilson | Hit tree at roomId=${choice.id} | Carving ${this.carvePath.length - 1} segments…`;
            return true;
          }

          // Loop detection / erasure
          const seenAt = this.walkIndex[choice.id];
          if (seenAt !== -1) {
            // erase everything after seenAt
            for (let i = seenAt + 1; i < this.walkPath.length; i++) {
              this.walkIndex[this.walkPath[i]] = -1;
            }
            this.walkPath.length = seenAt + 1;

            statusEl.textContent =
              `Algorithm: Wilson | Loop erased back to index ${seenAt} (roomId=${choice.id}) | Walk length: ${this.walkPath.length}`;
            return true;
          }

          // Extend walk
          this.walkPath.push(choice.id);
          this.walkIndex[choice.id] = this.walkPath.length - 1;

          const [nx, ny] = this._idToCoord(choice.id);
          cells[nx][ny].classList.add('current');

          statusEl.textContent =
            `Algorithm: Wilson | Walk step -> roomId=${choice.id} | Walk length: ${this.walkPath.length} | Remaining: ${this.remaining}`;
          return true;
        }

        if (this.phase === "carve") {
          if (!this.carvePath || this.carveI >= this.carvePath.length - 1) {
            // finish this walk
            this._clearWalkIndex();
            this.carvePath = null;
            this.phase = (this.remaining > 0) ? "pick" : "done";

            if (this.remaining <= 0) {
              statusEl.textContent = 'Done. (Wilson complete)';
              return false;
            }

            statusEl.textContent = `Algorithm: Wilson | Segment done | Remaining rooms: ${this.remaining}`;
            return true;
          }

          const aId = this.carvePath[this.carveI];
          const bId = this.carvePath[this.carveI + 1];

          const [ax, ay] = this._idToCoord(aId);
          const [bx, by] = this._idToCoord(bId);

          const wx = (ax + bx) / 2;
          const wy = (ay + by) / 2;

          clearHighlights();
          cells[ax][ay].classList.add('current');
          cells[bx][by].classList.add('current');
          cells[wx][wy].classList.add('between');

          // Ensure rooms are open when they join the tree
          this._markRoomInTree(aId);
          this._markRoomInTree(bId);

          // Carve the wall between
          setCell(wx, wy, true);

          this.carveI++;

          statusEl.textContent =
            `Algorithm: Wilson | Carve (${ax},${ay}) -> (${bx},${by}) via (${wx},${wy}) | Remaining rooms: ${this.remaining}`;
          return true;
        }

        statusEl.textContent = 'Done.';
        return false;
      }
    };

    const algorithms = {
      dfs: dfsState,
      prim: primState,
      kruskal: kruskalState,
      wilson: wilsonState,
    };

    function currentAlgo() {
      return algorithms[algoEl.value] || dfsState;
    }

    // ---------------------------
    // Control flow
    // ---------------------------

    function setAuto(on) {
      if (on) {
        btnAuto.textContent = 'Auto: On';
        autoTimer = setInterval(() => {
          const ok = stepOnce();
          if (!ok) setAuto(false);
        }, 30);
      } else {
        btnAuto.textContent = 'Auto: Off';
        clearInterval(autoTimer);
        autoTimer = null;
      }
    }

    function reset() {
      setAuto(false);

      N = Number(sizeEl.value) || 21;
      if (N % 2 === 0) N += 1;
      sizeEl.value = N;

      maze = Array.from({ length: N }, () => Array(N).fill(false));
      buildGrid();

      currentAlgo().init();
    }

    function stepOnce() {
      return currentAlgo().step();
    }

    btnReset.addEventListener('click', reset);
    btnStep.addEventListener('click', stepOnce);
    btnAuto.addEventListener('click', () => setAuto(!autoTimer));
    algoEl.addEventListener('change', reset);

    reset();
  </script>
</body>
</html>

