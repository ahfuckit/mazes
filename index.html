<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Step-by-2 Maze Carving Demo</title>
  <style>
    body { font-size: 1.1rem; }
    .row { display: flex; gap: 1%; flex-wrap: wrap; align-items: center; margin-bottom: 12px; }
    button { padding: 0.1em; }
    #grid { display: grid; background: #999; width: fit-content; margin: 1vmin }
    .cell { width: 1rem; height: 1rem; background: #111; }
    .path { background: #f5f5f5; }
    .current { border: -2px solid #00c8ff;}
    .between { background: #b700bf; } /* the carved “wall-between” cell this step */
    .room { background: #e9e9e9; }    /* optional: room cells look slightly different */
    code { background: #f2f200; padding: 1%; }
  </style>
</head>
<body>
  <div class="row">
    <button id="reset">Reset</button>
    <button id="step">Step</button>
    <button id="auto">Auto: Off</button>
    <a href="./index2.html">Play your way through some mazes!</a>
    <label>Size:
      <input id="size" type="number" min="5" step="2" value="21" style="width:100%; max-width:2vw">
    </label>
    <span id="status"></span>
  </div>

  <div id="grid"></div>

  <p>
    Watch what happens on each step:
    </p><br /><small id="deets">
    we jump to a neighbor by <code>±2</code> and carve the “between” cell at <code>dx/2</code>, <code>dy/2</code>.</small>
  </p>

  <script>
    const gridEl = document.getElementById('grid');
    const statusEl = document.getElementById('status');
    const sizeEl = document.getElementById('size');
    const btnReset = document.getElementById('reset');
    const btnStep = document.getElementById('step');
    const btnAuto = document.getElementById('auto');
    const deets = document.getElementById('deets');

    let N = 33;
    let maze = [];       // false = wall, true = path
    let cells = [];      // DOM refs
    let stack = [];      // iterative DFS stack of [x,y]
    let autoTimer = null;
    let lastBetween = null;

    const dirs = [
      [-2, 0], [2, 0], [0, -2], [0, 2],
    ];


    const givedeets = (deet) => { 
      deets.textContent =  deet;
    }

    function isValid(x, y) {
      return x >= 0 && x < N && y >= 0 && y < N;
      givedeets('isValid' + `${x} ,  ${y}`)
    }

    function shuffle(arr) {
      // good enough for demo
      for (let i = arr.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      givedeets('shuffle' + JSON.stringify(arr));
      return arr;
    }

    function setCell(x, y, isPath) {
      maze[x][y] = isPath;
      const el = cells[x][y];
      el.classList.toggle('path', isPath);
      el.classList.toggle('room', isPath && x % 2 === 1 && y % 2 === 1); // just for visuals
    }

    function clearHighlights() {
      // remove “current” from all: cheap because grid is small
      for (let x = 0; x < N; x++) for (let y = 0; y < N; y++) {
        cells[x][y].classList.remove('current');
        cells[x][y].classList.remove('between');
      }
      lastBetween = null;
    }

    function buildGrid() {
      gridEl.innerHTML = '';
      gridEl.style.gridTemplateColumns = `repeat(${N}, auto)`;

      cells = Array.from({ length: N }, () => Array(N));
      for (let x = 0; x < N; x++) {
        for (let y = 0; y < N; y++) {
          const el = document.createElement('div');
          el.className = 'cell';
          gridEl.appendChild(el);
          cells[x][y] = el;
        }
      }
    }

    function reset() {
      N = Number(sizeEl.value) || 21;
      if (N % 2 === 0) N += 1;           // keep odd
      sizeEl.value = N;

      maze = Array.from({ length: N }, () => Array(N).fill(false));
      stack = [];
      buildGrid();

      // start at (1,1) like your game
      setCell(1, 1, true);
      stack.push([1, 1]);

      clearHighlights();
      cells[1][1].classList.add('current');

      statusEl.textContent = `Stack: ${stack.length} | Carving…`;
    }

    function stepOnce() {
      if (stack.length === 0) {
        statusEl.textContent = 'Done. (Stack empty)';
        return false;
      }

      clearHighlights();

      const [x, y] = stack[stack.length - 1];
      cells[x][y].classList.add('current');

      const options = shuffle(dirs.slice());
      for (const [dx, dy] of options) {
        const nx = x + dx;
        const ny = y + dy;

        if (!isValid(nx, ny)) continue;
        if (maze[nx][ny]) continue; // already carved/visited “room”

        // THIS is your famous line: carve the between-cell
        const bx = x + dx / 2;
        const by = y + dy / 2;

        setCell(bx, by, true);
        setCell(nx, ny, true);

        cells[bx][by].classList.add('between');
        lastBetween = [bx, by];

        stack.push([nx, ny]);
        statusEl.textContent = `Move: (${x},${y}) -> (${nx},${ny}) | Between: (${bx},${by}) | Stack: ${stack.length}`;
        return true;
      }

      // no unvisited neighbors: backtrack (like returning from recursion)
      stack.pop();
      statusEl.textContent = `Backtrack from (${x},${y}) | Stack: ${stack.length}`;
      return true;
    }

    function setAuto(on) {
      if (on) {
        btnAuto.textContent = 'Auto: On';
        autoTimer = setInterval(() => {
          const ok = stepOnce();
          if (!ok) setAuto(false);
        }, 30);
      } else {
        btnAuto.textContent = 'Auto: Off';
        clearInterval(autoTimer);
        autoTimer = null;
      }
    }

    btnReset.addEventListener('click', () => reset());
    btnStep.addEventListener('click', () => stepOnce());
    btnAuto.addEventListener('click', () => setAuto(!autoTimer));

    reset();
  </script>
</body>
</html>


