<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Maze Carving Demo (Multiple Algorithms)</title>
  <style>
    body { font-size: 1.1rem; }
    .row { display: flex; gap: 1%; flex-wrap: wrap; align-items: center; margin-bottom: 12px; }
    button { padding: 0.1em; }
    #grid { display: grid; background: #999; width: fit-content; margin: 1vmin }
    .cell { width: 1rem; height: 1rem; background: #111; }
    .path { background: #f5f5f5; }
    /* negative border widths don’t render; outline works reliably */
    .current { outline: 2px solid #00c8ff; outline-offset: -2px; }
    .between { background: #b700bf; } /* the carved “wall-between” cell this step */
    .room { background: #e9e9e9; }    /* optional: room cells look slightly different */
    code { background: #f2f200; padding: 1%; }
    select, input { font-size: 1rem; }
  </style>
</head>
<body>
  <div class="row">
    <button id="reset">Reset</button>
    <button id="step">Step</button>
    <button id="auto">Auto: Off</button>
    <a href="./index2.html">Play your way through some mazes!</a>

    <label>Algorithm:
      <select id="algo">
        <option value="dfs">DFS Backtracker (±2 carve)</option>
        <option value="prim">Randomized Prim (frontier edges)</option>
      </select>
    </label>

    <label>Size:
      <input id="size" type="number" min="5" step="2" value="21" style="width:100%; max-width:2vw">
    </label>

    <span id="status"></span>
  </div>

  <div id="grid"></div>

  <p>
    Watch what happens on each step:
    <br />
    <small id="deets"></small>
  </p>

  <script>
    const gridEl = document.getElementById('grid');
    const statusEl = document.getElementById('status');
    const sizeEl = document.getElementById('size');
    const algoEl = document.getElementById('algo');
    const btnReset = document.getElementById('reset');
    const btnStep = document.getElementById('step');
    const btnAuto = document.getElementById('auto');
    const deets = document.getElementById('deets');

    let N = 33;
    let maze = [];       // false = wall, true = path
    let cells = [];      // DOM refs
    let autoTimer = null;
    let lastBetween = null;

    const dirs = [
      [-2, 0], [2, 0], [0, -2], [0, 2],
    ];

    const givedeets = (text) => { deets.textContent = text; };

    function isValid(x, y) {
      return x >= 0 && x < N && y >= 0 && y < N;
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function setCell(x, y, isPath) {
      maze[x][y] = isPath;
      const el = cells[x][y];
      el.classList.toggle('path', isPath);
      el.classList.toggle('room', isPath && x % 2 === 1 && y % 2 === 1); // just for visuals
    }

    function clearHighlights() {
      for (let x = 0; x < N; x++) for (let y = 0; y < N; y++) {
        cells[x][y].classList.remove('current');
        cells[x][y].classList.remove('between');
      }
      lastBetween = null;
    }

    function buildGrid() {
      gridEl.innerHTML = '';
      gridEl.style.gridTemplateColumns = `repeat(${N}, auto)`;

      cells = Array.from({ length: N }, () => Array(N));
      for (let x = 0; x < N; x++) {
        for (let y = 0; y < N; y++) {
          const el = document.createElement('div');
          el.className = 'cell';
          gridEl.appendChild(el);
          cells[x][y] = el;
        }
      }
    }

    // ---------------------------
    // Algorithms (init + step)
    // ---------------------------

    // Shared start point (odd,odd)
    const START = [1, 1];

    // DFS Backtracker (your original)
    const dfsState = {
      stack: [],
      init() {
        this.stack = [];
        const [sx, sy] = START;

        setCell(sx, sy, true);
        this.stack.push([sx, sy]);

        clearHighlights();
        cells[sx][sy].classList.add('current');

        statusEl.textContent = `Algorithm: DFS | Stack: ${this.stack.length} | Carving…`;
        givedeets(`DFS backtracker: choose a neighbor by ±2 and carve the “between” cell at dx/2, dy/2.`);
      },
      step() {
        if (this.stack.length === 0) {
          statusEl.textContent = 'Done. (DFS stack empty)';
          return false;
        }

        clearHighlights();

        const [x, y] = this.stack[this.stack.length - 1];
        cells[x][y].classList.add('current');

        const options = shuffle(dirs.slice());
        for (const [dx, dy] of options) {
          const nx = x + dx;
          const ny = y + dy;

          if (!isValid(nx, ny)) continue;
          if (maze[nx][ny]) continue; // already carved/visited “room”

          const bx = x + dx / 2;
          const by = y + dy / 2;

          setCell(bx, by, true);
          setCell(nx, ny, true);

          cells[bx][by].classList.add('between');
          lastBetween = [bx, by];

          this.stack.push([nx, ny]);
          statusEl.textContent = `Algorithm: DFS | Move: (${x},${y}) -> (${nx},${ny}) | Between: (${bx},${by}) | Stack: ${this.stack.length}`;
          return true;
        }

        this.stack.pop();
        statusEl.textContent = `Algorithm: DFS | Backtrack from (${x},${y}) | Stack: ${this.stack.length}`;
        return true;
      }
    };

    // Randomized Prim (frontier edges between carved and uncarved rooms)
    const primState = {
      frontier: [], // edges: {x,y,nx,ny,bx,by}
      init() {
        this.frontier = [];
        const [sx, sy] = START;

        setCell(sx, sy, true);
        this._addFrontierFrom(sx, sy);

        clearHighlights();
        cells[sx][sy].classList.add('current');

        statusEl.textContent = `Algorithm: Prim | Frontier: ${this.frontier.length} | Growing…`;
        givedeets(`Randomized Prim: maintain a frontier of edges from the carved region to uncarved rooms; pick one edge randomly, carve between + target room.`);
      },
      _addFrontierFrom(x, y) {
        for (const [dx, dy] of dirs) {
          const nx = x + dx;
          const ny = y + dy;
          if (!isValid(nx, ny)) continue;
          if (maze[nx][ny]) continue; // already carved room

          const bx = x + dx / 2;
          const by = y + dy / 2;
          this.frontier.push({ x, y, nx, ny, bx, by });
        }
      },
      step() {
        // Keep popping random edges until we find one that still leads to an uncarved room
        while (this.frontier.length > 0) {
          const idx = (Math.random() * this.frontier.length) | 0;
          const edge = this.frontier.splice(idx, 1)[0];

          const { x, y, nx, ny, bx, by } = edge;

          if (!isValid(nx, ny) || maze[nx][ny]) {
            continue; // stale/duplicate edge
          }

          clearHighlights();
          cells[x][y].classList.add('current');

          setCell(bx, by, true);
          setCell(nx, ny, true);

          cells[bx][by].classList.add('between');
          cells[nx][ny].classList.add('current'); // show the newly added room too
          lastBetween = [bx, by];

          this._addFrontierFrom(nx, ny);

          statusEl.textContent =
            `Algorithm: Prim | Add: (${nx},${ny}) via (${x},${y}) | Between: (${bx},${by}) | Frontier: ${this.frontier.length}`;
          return true;
        }

        statusEl.textContent = 'Done. (Prim frontier empty)';
        return false;
      }
    };

    const algorithms = {
      dfs: dfsState,
      prim: primState,
    };

    function currentAlgo() {
      return algorithms[algoEl.value] || dfsState;
    }

    // ---------------------------
    // Control flow
    // ---------------------------

    function reset() {
      // Stop auto if running (so changing algo/size doesn’t fight the timer)
      setAuto(false);

      N = Number(sizeEl.value) || 21;
      if (N % 2 === 0) N += 1; // keep odd
      sizeEl.value = N;

      maze = Array.from({ length: N }, () => Array(N).fill(false));
      buildGrid();

      currentAlgo().init();
    }

    function stepOnce() {
      return currentAlgo().step();
    }

    function setAuto(on) {
      if (on) {
        btnAuto.textContent = 'Auto: On';
        autoTimer = setInterval(() => {
          const ok = stepOnce();
          if (!ok) setAuto(false);
        }, 30);
      } else {
        btnAuto.textContent = 'Auto: Off';
        clearInterval(autoTimer);
        autoTimer = null;
      }
    }

    btnReset.addEventListener('click', reset);
    btnStep.addEventListener('click', stepOnce);
    btnAuto.addEventListener('click', () => setAuto(!autoTimer));

    // Reset whenever algorithm changes
    algoEl.addEventListener('change', reset);

    reset();
  </script>
</body>
</html>
